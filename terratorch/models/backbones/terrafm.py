# ------------------------------------------------------------------------------
# This file includes code copied and adapted from DINO:
# - DINO (https://github.com/facebookresearch/dino)
#
# ------------------------------------------------------------------------------

from __future__ import annotations

import math
import warnings
from collections.abc import Sequence
from pathlib import Path
from typing import Any

import torch
import torch.nn as nn
from torch import Tensor

from terratorch.registry import TERRATORCH_BACKBONE_REGISTRY

TerraFM_MEAN_S1 = [-12.7572, -19.6423]
TerraFM_STD_S1 = [5.8491, 5.8516]
TerraFM_MEAN_S2_L2A = [1033.9414, 1135.3391, 1382.2553, 1526.9789, 1883.3911, 2516.2726, 2782.7811,2829.3833, 2977.2936, 3004.2905, 2832.1983, 2186.6507]
TerraFM_STD_S2_L2A = [2761.4226, 807.365, 919.6919, 1221.4198, 1265.8146, 1323.0764, 1428.7845,1459.0343, 1497.9797, 1577.071, 1738.6128, 1620.8854]
TerraFM_MEAN_S3_L1C = [2153.94, 1937.191,1885.8236,1906.7263,2096.8369,2692.8083,3015.8569 ,2930.3957,3243.99,1389.849,2915.8289,2186.0514]
TerraFM_STD_S3_L1C= [581.6321,619.9756,714.7784,1018.3657,1021.4312,1116.4055,1265.8559 ,1234.6123,1374.9582,608.362,1547.9093,1336.0316]


def make_2tuple(x: int | tuple[int, int]) -> tuple[int, int]:
    if isinstance(x, tuple):
        if len(x) != 2:
            msg = "Tuple must have exactly 2 elements."
            raise ValueError(msg)
        return x

    if not isinstance(x, int):
        msg = "Expected int or tuple[int, int]"
        raise TypeError(msg)
    return (x, x)


def _no_grad_trunc_normal_(tensor: Tensor, mean: float, std: float, a: float, b: float) -> Tensor:
    # Cut & paste from PyTorch official master until it's in a few official releases - RW
    # Method based on https://people.sc.fsu.edu/~jburkardt/presentations/truncated_normal.pdf
    def norm_cdf(x: float) -> float:
        # Computes standard normal cumulative distribution function
        return (1.0 + math.erf(x / math.sqrt(2.0))) / 2.0

    if (mean < a - 2 * std) or (mean > b + 2 * std):
        warnings.warn(
            "mean is more than 2 std from [a, b] in nn.init.trunc_normal_. "
            "The distribution of values may be incorrect.",
            stacklevel=2,
        )

    with torch.no_grad():
        # Values are generated by using a truncated uniform distribution and
        # then using the inverse CDF for the normal distribution.
        # Get upper and lower cdf values
        lower = norm_cdf((a - mean) / std)
        upper = norm_cdf((b - mean) / std)

        # Uniformly fill tensor with values from [lower, upper], then translate to
        # [2*lower-1, 2*upper-1].
        tensor.uniform_(2 * lower - 1, 2 * upper - 1)

        # Use inverse cdf transform for normal distribution to get truncated
        # standard normal
        tensor.erfinv_()

        # Transform to proper mean, std
        tensor.mul_(std * math.sqrt(2.0))
        tensor.add_(mean)

        # Clamp to ensure it's in the proper range
        tensor.clamp_(min=a, max=b)
    return tensor


def trunc_normal_(tensor: Tensor, mean: float = 0.0, std: float = 1.0, a: float = -2.0, b: float = 2.0) -> Tensor:
    return _no_grad_trunc_normal_(tensor, mean, std, a, b)


def drop_path(x: Tensor, drop_prob: float = 0.0, training: bool = False) -> Tensor:
    if drop_prob == 0.0 or not training:
        return x
    keep_prob = 1 - drop_prob
    shape = (x.shape[0],) + (1,) * (x.ndim - 1)  # work with diff dim tensors, not just 2D ConvNets
    random_tensor = keep_prob + torch.rand(shape, dtype=x.dtype, device=x.device)
    random_tensor.floor_()  # binarize
    output = x.div(keep_prob) * random_tensor
    return output


class DropPath(nn.Module):
    """Drop paths (Stochastic Depth) per sample (when applied in main path of residual blocks)."""

    def __init__(self, drop_prob: float | None = None) -> None:
        super().__init__()
        self.drop_prob = drop_prob

    def forward(self, x: Tensor) -> Tensor:
        return drop_path(x, self.drop_prob, self.training)


class Mlp(nn.Module):
    def __init__(
        self,
        in_features: int,
        hidden_features: int | None = None,
        out_features: int | None = None,
        act_layer: type[nn.Module] = nn.GELU,
        drop: float = 0.0,
    ) -> None:
        super().__init__()
        out_features = out_features or in_features
        hidden_features = hidden_features or in_features
        self.fc1 = nn.Linear(in_features, hidden_features)
        self.act = act_layer()
        self.fc2 = nn.Linear(hidden_features, out_features)
        self.drop = nn.Dropout(drop)

    def forward(self, x: Tensor) -> Tensor:
        x = self.fc1(x)
        x = self.act(x)
        x = self.drop(x)
        x = self.fc2(x)
        x = self.drop(x)
        return x


class Attention(nn.Module):
    def __init__(
        self,
        dim: int,
        num_heads: int = 8,
        qkv_bias: bool = False,
        qk_scale: float | None = None,
        attn_drop: float = 0.0,
        proj_drop: float = 0.0,
    ) -> None:
        super().__init__()
        self.num_heads = num_heads
        head_dim = dim // num_heads
        self.scale = qk_scale or head_dim ** -0.5

        self.qkv = nn.Linear(dim, dim * 3, bias=qkv_bias)
        self.attn_drop = nn.Dropout(attn_drop)
        self.proj = nn.Linear(dim, dim)
        self.proj_drop = nn.Dropout(proj_drop)

    def forward(self, x: Tensor) -> tuple[Tensor, Tensor]:
        batch, tokens, channels = x.shape
        qkv = self.qkv(x).reshape(batch, tokens, 3, self.num_heads, channels // self.num_heads).permute(
            2, 0, 3, 1, 4
        )
        q, k, v = qkv[0], qkv[1], qkv[2]

        attn = (q @ k.transpose(-2, -1)) * self.scale
        attn = attn.softmax(dim=-1)
        attn = self.attn_drop(attn)

        x = (attn @ v).transpose(1, 2).reshape(batch, tokens, channels)
        x = self.proj(x)
        x = self.proj_drop(x)
        return x, attn


class Block(nn.Module):
    def __init__(
        self,
        dim: int,
        num_heads: int,
        mlp_ratio: float = 4.0,
        qkv_bias: bool = False,
        qk_scale: float | None = None,
        drop: float = 0.0,
        attn_drop: float = 0.0,
        drop_path_prob: float = 0.0,
        act_layer: type[nn.Module] = nn.GELU,
        norm_layer: type[nn.Module] = nn.LayerNorm,
    ) -> None:
        super().__init__()
        self.norm1 = norm_layer(dim)
        self.attn = Attention(
            dim,
            num_heads=num_heads,
            qkv_bias=qkv_bias,
            qk_scale=qk_scale,
            attn_drop=attn_drop,
            proj_drop=drop,
        )
        self.drop_path = DropPath(drop_path_prob) if drop_path_prob > 0 else nn.Identity()
        self.norm2 = norm_layer(dim)
        mlp_hidden_dim = int(dim * mlp_ratio)
        self.mlp = Mlp(in_features=dim, hidden_features=mlp_hidden_dim, act_layer=act_layer, drop=drop)

    def forward(self, x: Tensor, return_attention: bool = False) -> Tensor | Tensor:
        y, attn = self.attn(self.norm1(x))
        if return_attention:
            return attn
        x = x + self.drop_path(y)
        x = x + self.drop_path(self.mlp(self.norm2(x)))
        return x


class TokenProjection(nn.Module):
    def __init__(self, embed_dim: int, attn_dim: int) -> None:
        super().__init__()
        self.proj1 = nn.Linear(attn_dim, attn_dim, bias=False)
        self.norm_input = nn.LayerNorm(attn_dim)
        self.proj2 = nn.Linear(attn_dim, attn_dim)
        self.proj3 = nn.Linear(attn_dim, embed_dim)

    def forward(self, x: Tensor) -> Tensor:
        """
        Applies a sequence of linear projections used for Case 1 & N in modality augmentation.

        Steps:
        1. proj1 is shared between Case 1 and Case N (acts like value projection in attention).
        2. Applies LayerNorm to stabilize training and normalize features.
        3. In Case N, proj2 is applied after the weighted mean operation.
        4. proj3 projects to the final embedding dimension.
        Args:
            tokens (Tensor): Input tensor of shape [B, N, input_dim], where
                             B = batch size, N = number of tokens.

        Returns:
            Tensor: Projected output of shape [B, N, final_dim].
        """
        x = self.proj1(x)  # V in cross attn
        x = self.norm_input(x)
        x = self.proj2(x)
        x = self.proj3(x)  # final projection
        return x


class PatchEmbed(nn.Module):
    def __init__(
        self,
        img_size: int,
        embed_dim: int,
        patch_size: int,
        in_chans_s1: int,
        in_chans_s2: int,
    ) -> None:
        super().__init__()
        attn_dim = embed_dim * 3  # from Panopticon design
        self.img_size = img_size
        self.patch_size = patch_size
        num_patches = (img_size // patch_size) * (img_size // patch_size)
        self.num_patches = num_patches

        self.conv2d_s2_l2a = nn.Conv2d(in_chans_s2, attn_dim, kernel_size=patch_size, stride=patch_size)
        self.conv2d_s2_l1c = nn.Conv2d(in_chans_s2, attn_dim, kernel_size=patch_size, stride=patch_size)
        self.conv2d_s1 = nn.Conv2d(in_chans_s1, attn_dim, kernel_size=patch_size, stride=patch_size)

        self.projection = TokenProjection(embed_dim=embed_dim, attn_dim=attn_dim)
        self.s2_l2a_embed = nn.Parameter(torch.zeros(1, attn_dim))
        self.s2_l1c_embed = nn.Parameter(torch.zeros(1, attn_dim))
        self.s1_embed = nn.Parameter(torch.zeros(1, attn_dim))
        self.attn_dim = attn_dim

    def forward(self, x12: Tensor, is_l2a: bool = False) -> Tensor:
        batch, channels, _, _ = x12.shape
        del batch
        if channels == 2:
            x = self.conv2d_s1(x12).flatten(2).transpose(1, 2)
            x = x + self.s1_embed
        elif is_l2a:
            x = self.conv2d_s2_l2a(x12).flatten(2).transpose(1, 2)
            x = x + self.s2_l2a_embed
        else:
            x = self.conv2d_s2_l1c(x12).flatten(2).transpose(1, 2)
            x = x + self.s2_l1c_embed

        x = self.projection(x)
        return x


class TerraFM(nn.Module):
    def __init__(
        self,
        img_size: Sequence[int] = (224,),
        patch_size: int = 16,
        in_chans: int = 3,
        num_classes: int = 0,
        embed_dim: int = 768,
        depth: int = 12,
        num_heads: int = 12,
        mlp_ratio: float = 4.0,
        qkv_bias: bool = False,
        qk_scale: float | None = None,
        drop_rate: float = 0.0,
        attn_drop_rate: float = 0.0,
        drop_path_rate: float = 0.0,
        norm_layer: type[nn.Module] = nn.LayerNorm,
        use_l2a_patch_embed: bool = True,
        **kwargs: Any,
    ) -> None:
        super().__init__()
        del kwargs
        self.num_features = self.embed_dim = embed_dim
        self.use_l2a_patch_embed = use_l2a_patch_embed

        self.patch_embed = PatchEmbed(
            img_size=img_size[0],
            patch_size=patch_size,
            in_chans_s1=2,
            in_chans_s2=12,
            embed_dim=embed_dim,
        )
        num_patches = self.patch_embed.num_patches

        self.cls_token = nn.Parameter(torch.zeros(1, 1, embed_dim))
        self.pos_embed = nn.Parameter(torch.zeros(1, num_patches + 1, embed_dim))
        self.pos_drop = nn.Dropout(p=drop_rate)

        dpr = [x.item() for x in torch.linspace(0, drop_path_rate, depth)]  # stochastic depth decay rule
        self.blocks = nn.ModuleList(
            [
                Block(
                    dim=embed_dim,
                    num_heads=num_heads,
                    mlp_ratio=mlp_ratio,
                    qkv_bias=qkv_bias,
                    qk_scale=qk_scale,
                    drop=drop_rate,
                    attn_drop=attn_drop_rate,
                    drop_path_prob=dpr[i],
                    norm_layer=norm_layer,
                )
                for i in range(depth)
            ]
        )
        self.norm = norm_layer(embed_dim)

        # Classifier head
        self.head = nn.Linear(embed_dim, num_classes) if num_classes > 0 else nn.Identity()

        trunc_normal_(self.pos_embed, std=0.02)
        trunc_normal_(self.cls_token, std=0.02)
        self.apply(self._init_weights)

    def _init_weights(self, module: nn.Module) -> None:
        if isinstance(module, nn.Linear):
            trunc_normal_(module.weight, std=0.02)
            if isinstance(module, nn.Linear) and module.bias is not None:
                nn.init.constant_(module.bias, 0)
        elif isinstance(module, nn.LayerNorm):
            nn.init.constant_(module.bias, 0)
            nn.init.constant_(module.weight, 1.0)

    def interpolate_pos_encoding(self, x: Tensor, width: int, height: int) -> Tensor:
        npatch = x.shape[1] - 1
        base = self.pos_embed.shape[1] - 1
        if npatch == base and width == height:
            return self.pos_embed
        class_pos_embed = self.pos_embed[:, 0]
        patch_pos_embed = self.pos_embed[:, 1:]
        dim = x.shape[-1]
        width_scaled = width // self.patch_embed.patch_size
        height_scaled = height // self.patch_embed.patch_size
        width_scaled = width_scaled + 0.1  # avoid floating point error in interpolation
        height_scaled = height_scaled + 0.1
        patch_pos_embed = nn.functional.interpolate(
            patch_pos_embed.reshape(1, int(math.sqrt(base)), int(math.sqrt(base)), dim).permute(0, 3, 1, 2),
            scale_factor=(width_scaled / math.sqrt(base), height_scaled / math.sqrt(base)),
            mode="bicubic",
        )
        if int(width_scaled) != patch_pos_embed.shape[-2] or int(height_scaled) != patch_pos_embed.shape[-1]:
            msg = "Interpolated positional embedding has unexpected shape."
            raise RuntimeError(msg)
        patch_pos_embed = patch_pos_embed.permute(0, 2, 3, 1).view(1, -1, dim)
        return torch.cat((class_pos_embed.unsqueeze(0), patch_pos_embed), dim=1)

    def prepare_tokens(self, x: Tensor, *, is_l2a: bool | None = None) -> Tensor:
        if is_l2a is None:
            is_l2a = self.use_l2a_patch_embed
        batch, _, width, height = x.shape
        x = self.patch_embed(x, is_l2a=is_l2a)  # patch linear embedding

        # add the [CLS] token to the embed patch tokens
        cls_tokens = self.cls_token.expand(batch, -1, -1)
        x = torch.cat((cls_tokens, x), dim=1)

        # add positional encoding to each token
        x = x + self.interpolate_pos_encoding(x, width, height)

        return self.pos_drop(x)

    def forward_features(self, x: Tensor, *, is_l2a: bool | None = None) -> Tensor:
        return self.forward(x, is_l2a=is_l2a)

    def forward(self, x: Tensor, *, is_l2a: bool | None = None) -> Tensor:
        x = self.prepare_tokens(x, is_l2a=is_l2a)
        for blk in self.blocks:
            x = blk(x)
        x = self.norm(x)
        return x[:, 0]

    def get_last_selfattention(self, x: Tensor, *, is_l2a: bool | None = None) -> Tensor:
        x = self.prepare_tokens(x, is_l2a=is_l2a)
        for i, blk in enumerate(self.blocks):
            if i < len(self.blocks) - 1:
                x = blk(x)
            else:
                # return attention of the last block
                return blk(x, return_attention=True)
        msg = "No blocks available to compute attention."
        raise RuntimeError(msg)

    def get_intermediate_layers(
        self,
        x: Tensor,
        n: int = 1,
        *,
        return_class_token: bool = False,
        norm: bool = False,
        is_l2a: bool | None = None,
    ) -> list[Tensor] | tuple[list[Tensor], list[Tensor]]:
        x = self.prepare_tokens(x, is_l2a=is_l2a)
        # we return the output tokens from the `n` last blocks
        output = []
        for i, blk in enumerate(self.blocks):
            x = blk(x)
            if len(self.blocks) - i <= n:
                output.append(x)
        if norm:
            output = [self.norm(out) for out in output]
        class_tokens = [out[:, 0] for out in output]
        output = [out[:, 1:] for out in output]
        if return_class_token:
            return output, class_tokens
        return output

    def extract_feature(
        self,
        images: Tensor,
        return_h_w: bool = True,  # noqa: FBT002
        out_indices: Sequence[int] = (3, 5, 7, 11),
        is_l2a: bool | None = None,
    ) -> list[Tensor]:
        del return_h_w
        x = self.prepare_tokens(images, is_l2a=is_l2a)
        output = []
        height = int(images.shape[2] / self.patch_embed.patch_size)
        width = int(images.shape[3] / self.patch_embed.patch_size)
        for i, blk in enumerate(self.blocks):
            x = blk(x)
            if i in out_indices:
                out = x[:, 1:]
                out = self.norm(out)
                batch, _, channels = out.shape
                out = out.reshape(batch, height, width, channels).permute(0, 3, 1, 2).contiguous()
                output.append(out)

        return output


def terrafm_base_model(patch_size: int = 16, **kwargs: Any) -> TerraFM:
    model = TerraFM(
        patch_size=patch_size,
        embed_dim=768,
        depth=12,
        num_heads=12,
        mlp_ratio=4,
        qkv_bias=True,
        **kwargs,
    )
    return model


def terrafm_large_model(patch_size: int = 16, **kwargs: Any) -> TerraFM:
    model = TerraFM(
        patch_size=patch_size,
        embed_dim=1024,
        depth=24,
        num_heads=16,
        mlp_ratio=4,
        qkv_bias=True,
        **kwargs,
    )
    return model


class TerraFMBackbone(nn.Module):
    """Wrapper that exposes TerraFM features the way TerraTorch backbones expect."""

    def __init__(self, model: TerraFM, out_indices: Sequence[int] | None = None, default_is_l2a: bool = True) -> None:
        super().__init__()
        self.model = model
        self.out_indices = out_indices
        if self.out_indices is not None:
            self.out_indices = tuple(self.out_indices)
        self.default_is_l2a = default_is_l2a
        if self.out_indices is None:
            self.out_channels = self.model.embed_dim
        else:
            self.out_channels = [self.model.embed_dim for _ in self.out_indices]

    def forward(self, x: Tensor, *, is_l2a: bool | None = None) -> list[Tensor]:
        use_l2a = self.default_is_l2a if is_l2a is None else is_l2a
        if self.out_indices is None or len(self.out_indices) == 0:
            return self.model(x, is_l2a=use_l2a)
        return self.model.extract_feature(x, out_indices=self.out_indices, is_l2a=use_l2a)

    @property
    def embed_dim(self) -> int:
        return self.model.embed_dim


def _load_checkpoint(model: nn.Module, ckpt_path: str | Path) -> None:
    ckpt_path = Path(ckpt_path)
    if not ckpt_path.exists():
        msg = f"Checkpoint file {ckpt_path} not found."
        raise FileNotFoundError(msg)

    checkpoint = torch.load(ckpt_path, map_location="cpu")
    if isinstance(checkpoint, dict) and "state_dict" in checkpoint:
        checkpoint = checkpoint["state_dict"]

    if isinstance(checkpoint, dict):
        checkpoint = {k.replace("module.", ""): v for k, v in checkpoint.items()}

    missing, unexpected = model.load_state_dict(checkpoint, strict=False)
    print(f"Loaded TerraFM checkpoint from {ckpt_path}")
    if missing:
        warnings.warn(f"Missing keys when loading TerraFM checkpoint {ckpt_path}: {sorted(missing)}", stacklevel=2)
    if unexpected:
        warnings.warn(f"Unexpected keys when loading TerraFM checkpoint {ckpt_path}: {sorted(unexpected)}", stacklevel=2)


def _build_terrafm_backbone(
    builder: callable,
    *,
    pretrained: bool = False,  # noqa: FBT001, FBT002
    ckpt_path: str | None = None,
    out_indices: Sequence[int] | None = None,
    is_l2a: bool = True,
    **kwargs: Any,
) -> TerraFMBackbone:
    builder_kwargs = dict(kwargs)
    use_l2a = builder_kwargs.pop("use_l2a_patch_embed", is_l2a)
    model = builder(use_l2a_patch_embed=use_l2a, **builder_kwargs)

    if pretrained:
        if ckpt_path is None:
            msg = "ckpt_path must be provided when pretrained=True for TerraFM."
            raise ValueError(msg)
        _load_checkpoint(model, ckpt_path)
    elif ckpt_path is not None:
        _load_checkpoint(model, ckpt_path)

    return TerraFMBackbone(model, out_indices=out_indices, default_is_l2a=use_l2a)


@TERRATORCH_BACKBONE_REGISTRY.register
def terrafm_base(
    pretrained: bool = False,  
    ckpt_path: str | None = None,
    out_indices: Sequence[int] | None = None,
    is_l2a: bool = True,
    **kwargs: Any,
) -> TerraFMBackbone:
    return _build_terrafm_backbone(
        terrafm_base_model,
        pretrained=pretrained,
        ckpt_path=ckpt_path,
        out_indices=out_indices,
        is_l2a=is_l2a,
        **kwargs,
    )


@TERRATORCH_BACKBONE_REGISTRY.register
def terrafm_large(
    pretrained: bool = False,  
    ckpt_path: str | None = None,
    out_indices: Sequence[int] | None = None,
    is_l2a: bool = True,
    **kwargs: Any,
) -> TerraFMBackbone:
    return _build_terrafm_backbone(
        terrafm_large_model,
        pretrained=pretrained,
        ckpt_path=ckpt_path,
        out_indices=out_indices,
        is_l2a=is_l2a,
        **kwargs,
    )


__all__ = [
    "TerraFM",
    "terrafm_base",
    "terrafm_large",
    "TerraFMBackbone",
]
